#!/usr/bin/env python3
"""
Python replacement for node_js2c - converts JavaScript files to C++ source
For Node.js v22 build on PPC64 Big Endian
"""
import os
import sys
import re
from pathlib import Path

def get_var_name(filepath):
    """Convert filepath to valid C++ variable name"""
    name = os.path.basename(filepath)
    # Remove extension
    name = os.path.splitext(name)[0]
    # Replace non-alphanumeric with underscore
    name = re.sub(r'[^a-zA-Z0-9]', '_', name)
    # Handle internal modules
    path_str = str(filepath).replace('/', '_').replace('.', '_')
    if 'internal' in path_str:
        name = 'internal_' + name
    return name

def is_ascii(data):
    """Check if all bytes are ASCII (0-127)"""
    return all(b < 128 for b in data)

def is_latin1(data):
    """Check if all bytes are Latin-1 (0-255)"""
    return all(b < 256 for b in data)

def encode_as_array(data, var_name, is_two_byte=False):
    """Encode data as C++ array"""
    arr_type = 'uint16_t' if is_two_byte else 'uint8_t'
    resource_type = 'StaticExternalTwoByteResource' if is_two_byte else 'StaticExternalOneByteResource'
    
    lines = []
    lines.append(f'static const {arr_type} {var_name}_raw[] = {{')
    
    # Convert to array values
    values = []
    for b in data:
        values.append(str(b))
    
    # Write in chunks of 16 values per line
    for i in range(0, len(values), 16):
        chunk = values[i:i+16]
        lines.append('  ' + ', '.join(chunk) + ',')
    
    lines.append('};')
    lines.append('')
    lines.append(f'static {resource_type} {var_name}_resource({var_name}_raw, {len(data)}, nullptr);')
    lines.append('')
    
    return '\n'.join(lines)

def process_file(filepath, root_dir):
    """Process a single JavaScript file"""
    with open(filepath, 'rb') as f:
        data = f.read()
    
    # Get relative path for module ID
    try:
        rel_path = os.path.relpath(filepath, root_dir)
    except:
        rel_path = filepath
    
    var_name = get_var_name(rel_path)
    
    # Determine encoding
    if is_ascii(data):
        code_type = 'ascii'
    elif is_latin1(data):
        code_type = 'latin1'
    else:
        code_type = 'twobyte'
    
    return var_name, rel_path, encode_as_array(list(data), var_name, code_type == 'twobyte'), len(data)

def find_files(directory, extensions):
    """Find all files with given extensions"""
    files = []
    for ext in extensions:
        for f in Path(directory).rglob(f'*{ext}'):
            files.append(str(f))
    return sorted(files)

def main():
    if len(sys.argv) < 3:
        print(f'Usage: {sys.argv[0]} output.cc directory [extra-files...]', file=sys.stderr)
        return 1
    
    output_file = sys.argv[1]
    sources = sys.argv[2:]
    
    root_dir = os.getcwd()
    all_files = []
    
    # Process directories and files
    for src in sources:
        if os.path.isdir(src):
            all_files.extend(find_files(src, ['.js', '.mjs']))
        elif os.path.isfile(src):
            all_files.append(src)
    
    # Remove duplicates and sort
    all_files = sorted(set(all_files))
    
    print(f'Processing {len(all_files)} files...', file=sys.stderr)
    
    # Generate output
    output = []
    output.append('// Auto-generated by js2c.py')
    output.append('#include <cstdint>')
    output.append('#include "env-inl.h"')
    output.append('#include "node_builtins.h"')
    output.append('#include "node_external_reference.h"')
    output.append('#include "node_internals.h"')
    output.append('#include "simdutf.h"')
    output.append('#include "util.h"')
    output.append('')
    output.append('namespace node {')
    output.append('namespace builtins {')
    output.append('')
    
    modules = []
    
    for filepath in all_files:
        try:
            var_name, rel_path, code, size = process_file(filepath, root_dir)
            output.append(f'// Source: {rel_path}')
            output.append(code)
            modules.append((var_name, rel_path, size))
        except Exception as e:
            print(f'Warning: Failed to process {filepath}: {e}', file=sys.stderr)
    
    # Generate registration function
    output.append('')
    output.append('void BuiltinLoader::LoadJavaScriptSource() {')
    for var_name, rel_path, size in modules:
        module_id = rel_path.replace('\\', '/').replace('.js', '').replace('.mjs', '')
        output.append(f'  source_.emplace("{module_id}", UnionBytes(&{var_name}_resource));')
    output.append('}')
    output.append('')
    output.append('}  // namespace builtins')
    output.append('}  // namespace node')
    
    # Write output
    with open(output_file, 'w') as f:
        f.write('\n'.join(output))
    
    print(f'Generated {output_file} with {len(modules)} modules', file=sys.stderr)
    return 0

if __name__ == '__main__':
    sys.exit(main())
